[{"content":"I had to choose a project for one course of my masters degree, so I decided to implement a QOI encoder/decoder using Go. I called it goi, but later realized there was already a repository called exactly the same doing exactly the same :(. Nevertheless, I decided to leave the name as it was as I\u0026rsquo;m pretty bad at naming things hehe.\nWhat is QOI? # QOI stands for Quite OK Image. According to its site, QOI is fast. It losslessly compresses images to a similar size of PNG, while offering 20x-50x faster encoding and 3x-4x faster decoding. The file format specification is only one page long, which makes it quite easy to read, it is also really simple, so it is a nice weekend project to build.\nQOI File Spec # Header # A QOI file starts with a 14 byte header containing metadata about the image.\ntype QoiHeader struct { magic [4]byte // magic bytes \u0026#34;qoif\u0026#34; width uint32 // image width in pixels (Big Endian) height uint32 // image height in pixels (Big Endian) channels uint8 // 3 = RGB, 4 = RGBA colorspace uint8 // 0 = sRGB with linear alpha, 1 = all channels linear } Only the width and height fields are actually used by the encoder/decoder. The other fields are purely informative.\nData Chunks # After the header, we have a series of data chunks which contains the actual image data. There are 6 kind of data chunks, each identified by an operation name.\nQOI_OP_RGB # This chunks consists of 4 bytes, storing the raw RGB values from the pixel. The first byte is the OP id 0xfe (or 11111110 in binary) following the red, blue and green values from the corresponding pixel.\n┌─ QOI_OP_RGB ────┬─────────┬─────────┬─────────┐ │ Byte[0] │ Byte[1] │ Byte[2] │ Byte[3] │ │ 7 6 5 4 3 2 1 0 │ 7 ... 0 │ 7 ... 0 │ 7 ... 0 │ │─────────────────┼─────────┼─────────┼─────────│ │ 1 1 1 1 1 1 1 0 │ red │ green │ blue │ └─────────────────┴─────────┴─────────┴─────────┘ QOI_OP_RGBA # Same as QOI_OP_RGB but we store the full RGBA value, so we need an extra byte for the alpha value. The first byte is 0xff (or 11111111 in binary).\n┌─ QOI_OP_RGB ────┬─────────┬─────────┬─────────┬─────────┐ │ Byte[0] │ Byte[1] │ Byte[2] │ Byte[3] │ Byte[4] │ │ 7 6 5 4 3 2 1 0 │ 7 ... 0 │ 7 ... 0 │ 7 ... 0 │ 7 ... 0 │ │─────────────────┼─────────┼─────────┼─────────┼─────────│ │ 1 1 1 1 1 1 1 0 │ red │ green │ blue │ alpha │ └─────────────────┴─────────┴─────────┴─────────┴─────────┘ QOI_OP_INDEX # A running 64 length array (zero initialized) of previously seen pixel values is maintained by the encoder/decoder. Previously seen pixels are stored in this array at the position given by the following hash function:\nfunc hashPixel(px color.NRGBA) uint8 { return (px.R*3 + px.G*5 + px.B*7 + px.A*11) % 64 } Then we store a single byte starting with 00 followed by the index into the array.\n┌─ QOI_OP_INDEX ────┐ │ Byte[0] │ │ 7 6 5 4 3 2 1 0 │ │─────┼─────────────│ │ 0 0 │ index │ └─────┴─────────────┘ QOI_OP_DIFF # ┌─ QOI_OP_DIFF ─────────┐ │ Byte[0] │ │ 7 6 5 4 3 2 1 0 │ │─────┼─────┼─────┼─────│ │ 0 1 │ dr │ dg │ db │ └─────┴─────┴─────┴─────┘ QOI_OP_LUMA # ┌─ QOI_OP_LUMA ─────┬───────────────────┐ │ Byte[0] │ Byte[1] │ │ 7 6 5 4 3 2 1 0 │ 7 6 5 4 3 2 1 0 │ │─────┼─────────────┼─────────┼─────────│ │ 1 0 │ diff green │ dr - dg │ db - dg │ └─────┴─────────────┴─────────┴─────────┘ QOI_OP_RUN # The encoder/decoder also keeps track of the last visited pixel and a run variable. We save this OP as a single byte starting with 11 followed by the value run-1.\n┌─ QOI_OP_RUN ──────┐ │ Byte[0] │ │ 7 6 5 4 3 2 1 0 │ │─────┼─────────────│ │ 1 1 │ run - 1 │ └─────┴─────────────┘ If a pixel is equal to the previously seen pixel we increment the run variable by one. Note that because of the way this OP is represented, values 0xfe and 0xff are forbidden, since it will collide with the QOI_OP_RGB and QOI_OP_RGBA representation, so run can have a value of at most 63.\n","date":"10 November 2023","permalink":"/projects/goi/","section":"Projects","summary":"I had to choose a project for one course of my masters degree, so I decided to implement a QOI encoder/decoder using Go.","title":"Goi"},{"content":"","date":"10 November 2023","permalink":"/","section":"mateogo42","summary":"","title":"mateogo42"},{"content":"","date":"10 November 2023","permalink":"/projects/","section":"Projects","summary":"","title":"Projects"},{"content":" Sudoku # ","date":"10 November 2023","permalink":"/projects/sudoku/","section":"Projects","summary":" Sudoku # ","title":"Sudoku"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"1 January 0001","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]